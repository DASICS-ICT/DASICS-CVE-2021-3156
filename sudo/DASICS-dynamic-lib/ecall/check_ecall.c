#include <dasics_ecall.h>
#include <my_stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <fcntl.h>
#include <asm/dasics_ucontext.h>

ecall_check_t syscall_check[__NR_syscalls];

struct dirent_ecall
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];		/* We must not include limits.h! */
  };

/*  
 * default no check for the ecall 
 */
int default_ecall_check_handler(uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
    // #ifdef DASICS_DEBUG
        my_printf("[DEBUG]: catch user syscall %d\n", a7);
    // #endif
    return 0;    
}


/* default ecall error handler */
void default_ecall_error_handler()
{
    exit(1);
}

void neglect_ecal_handler(void * regs)
{
    regs_context_t * context = (regs_context_t *)regs;
    // Ecall error
    context->a0 = -1;
}


/* init all syscall's check handler */
void init_syscall_check()
{
    for (int i = 0; i < __NR_syscalls; i++)
    {
        syscall_check[i].check = default_ecall_check_handler;
        syscall_check[i].handle_error = default_ecall_error_handler;
    }

    syscall_check[__NR_openat].check     = (long (*)())ecall_check_openat;
    syscall_check[__NR_getdents64].check = (long (*)())ecall_check_getdents64;
    syscall_check[__NR_fstatat].check    = (long (*)())ecall_check_fstatat;
    syscall_check[__NR_setgid].check     = (long (*)())ecall_check_setgid;
    syscall_check[__NR_setuid].check     = (long (*)())ecall_check_setuid;
    syscall_check[__NR_execve].check     = (long (*)())ecall_check_execve;

    // neglect
    syscall_check[__NR_setgid].handle_error     = (long (*)())neglect_ecal_handler;
    syscall_check[__NR_setuid].handle_error     = (long (*)())neglect_ecal_handler;
    
}

int ecall_check_openat(int dirfd, const char *pathname, int flags, mode_t mode)
{
    my_printf("[DEBUG_ECALL(openat)]: Try to do openat\n");
    if (pathname)
        my_printf("[DEBUG_ECALL(openat)]: Openat try to open path %s\n", pathname);
    return 0;
}



int ecall_check_getdents64(unsigned int fd, void * linux_dirent64_dirp, unsigned int count)
{
    my_printf("[DEBUG_ECALL(getdents64)]: Try to do getdents\n");
    my_printf("[DEBUG_ECALL(getdents64)]: struct linux_dirent_dirp buffer: 0x%lx, size: 0x%lx\n", \
        (uint64_t)linux_dirent64_dirp, count
    );
    return 0;
}

int ecall_check_fstatat(int dirfd, const char *pathname, struct stat * stat_buf, int flags)
{
    my_printf("[DEBUG_ECALL(fstatat)]: Try to do fstatat\n");
    if (pathname)
        my_printf("[DEBUG_ECALL(fstatat)]: Pathname: %s\n", pathname);
    my_printf("[DEBUG_ECALL(fstatat)]: struct stat: 0x%lx, size: 0x%lx\n", \
        (uint64_t)stat_buf, sizeof(*stat_buf)
    );
    return 0;
}

int ecall_check_setuid(int uid)
{
    my_printf("[DEBUG_ECALL(setuid)]: Untrusted area try to do setuid: %d\n", uid);
    if (uid == 0)
    {
        my_printf("[DEBUG_ECALL(setuid)]: Illegal operation: setuid to root, ignore!\n");
        return -1;
    }
    
}


int ecall_check_setgid(int gid)
{
    my_printf("[DEBUG_ECALL(setgid)]: Untrusted area try to do setgid: %d\n", gid);
    if (gid == 0)
    {
        my_printf("[DEBUG_ECALL(setgid)]: Illegal operation: setgid to root, ignore!\n");
        return -1;
    }

}

int ecall_check_execve(char * filename, char* argv[], char * envp[])
{
    my_printf("[DEBUG_ECALL(execve)]: Untrusted area try to execve %s\n", filename);
    return 0;
}
#include <redirect.h>
#include <stdlib.h>

// List
LIST_HEAD(redirect_table);

// switch
int redirect_switch = 0;
int force_redirect_switch = 0;


static inline int __dasics_linker_strcpy(char *dest, const char *src)
{
    char *tmp = dest;

    while (*src) {
        *dest++ = *src++;
    }

    *dest = '\0';

    return tmp;
}

static inline int __dasics_linker_strcmp(const char *str1, const char *str2)
{
    while (*str1 && *str2) {
        if (*str1 != *str2) {
            return (*str1) - (*str2);
        }
        ++str1;
        ++str2;
    }
    return (*str1) - (*str2);
}

/**
 * @brief Find one item from the list 
 */
static redirect_t * find_item(const char *name)
{
    redirect_t * item_entry = NULL;
    redirect_t * item_q = NULL;

    list_for_each_entry_safe(item_entry, item_q ,&redirect_table, list)
    {
        // my_printf("%s\n", item_entry->name);
        if (!__dasics_linker_strcmp(name, item_entry->name))
        {
            return item_entry;
        }
    }
    return NULL;
}


/* Add one item  */
int add_redirect_item(const char *func_name)
{
    if (find_item(func_name) != NULL)
    {
        my_printf("[Warning]: There has exited one redirect item: %s\n", func_name);
        return 0;
    }

    // Malloc one
    redirect_t * new_item = (redirect_t *)malloc(sizeof(redirect_t));

    __dasics_linker_strcpy(new_item->name, func_name);


    list_add_tail(&new_item->list, &redirect_table);

    return 0;
}

/* Delete one item from list */ 
int delete_redirect_item(const char *func_name)
{
    redirect_t *delete_item = NULL;

    // Find one item
    if ((delete_item = find_item(func_name)) == NULL)
    {
        my_printf("[Warning]: There has no one redirect item: %s\n", func_name);
        return 0;
    }


    list_del(&delete_item->list);

    free(delete_item);

    return 0;
}

/* Force relocation */
uint64_t force_redirect(umain_got_t * entry, const char * func_name, uint64_t target)
{
    if (!redirect_switch) return target;

    // Never redirect __libc_start_main
    if (!__dasics_linker_strcmp(func_name, "__libc_start_main"))
    {
        return target;
    }


    // If force_redirect_switch open, force redirect
    if (find_item(func_name) == NULL && !force_redirect_switch) return target;
    /* Get the target area of the target addr */
    umain_got_t * _target_got = _get_trap_area(target);   

    if (_target_got == NULL)
    {
        my_printf("[ERROR] DASICS error! target addr error: 0x%lx!\n", target);
        exit(1);
    }
    // get one redirect address
    /* The trusted area want to call trusted func */
    if ((entry->_flags & MAIN_AREA) &&
         (_target_got->_flags & MAIN_AREA))
    {
        if (_target_got->_point_got != NULL)
        {
            // #ifdef DASICS_DEBUG
            // my_printf("reloc: change %s to: 0x%lx\n", \ 
            // func_name, (target - _target_got->l_addr) + _target_got->_point_got->l_addr);
            // #endif
            return (target - _target_got->l_addr) + _target_got->_point_got->l_addr;
        }
    }

    return target;
}

// Open teh switch
int open_redirect()
{
    redirect_switch = 1;
}

// Close the switch
int close_redirect()
{
    redirect_switch = 0;
}


int force_redirect_open()
{
    force_redirect_switch = 1;
}

int force_redirect_close()
{
    force_redirect_switch = 0;
}
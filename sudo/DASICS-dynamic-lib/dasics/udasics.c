#include <stdio.h>
#include <stdint.h>
#include <udasics.h>
#include <my_stdio.h>
#include <utrap.h>
#include <utrap_handler.h>
#include <dasics_link.h>
#include <dasics_link_manager.h>
#include <cross.h>

uint64_t umaincall_helper;

void register_udasics(uint64_t funcptr) 
{
    umaincall_helper = (funcptr != 0) ? funcptr : (uint64_t) dasics_umaincall_helper;
    csr_write(0x8b0, (uint64_t)dasics_umaincall);
    csr_write(0x005, (uint64_t)dasics_ufault_entry);
}

void unregister_udasics(void) 
{
    csr_write(0x8b0, 0);
    csr_write(0x005, 0);    
}

// uint64_t dasics_umaincall_helper(UmaincallTypes type, uint64_t arg0, uint64_t arg1, uint64_t arg2)
// {
//     uint64_t dasics_return_pc = csr_read(0x8a4);            // DasicsReturnPC
//     uint64_t dasics_free_zone_return_pc = csr_read(0x8a5);  // DasicsFreeZoneReturnPC

//     uint64_t retval = 0;

//     switch (type)
//     {
//         // TODO: print supports variable arguments
//         case Umaincall_PRINT:
//             if (!arg0) break;
//             if (arg1) goto print_arg1; 
//             // printf((char *)arg0);
//             break;
//         print_arg1:
//             if (arg2) goto print_arg2;
//             // printf((char *)arg0, arg1);
//             break;
//         print_arg2:
//             // printf((char *)arg0, arg1, arg2);
//             break;
//         default:
//             // printf("Warning: Invalid umaincall number %u!\n", type); //could not use // printf in kernel
//             break;
//     }

//     csr_write(0x8a4, dasics_return_pc);             // DasicsReturnPC
//     csr_write(0x8a5, dasics_free_zone_return_pc);   // DasicsFreeZoneReturnPC

//     return retval;
// }

// unsigned long ATTR_ULIB_TEXT _generate_addr() {
// 	int i = 0xf;
// 	unsigned long ptr = 0; 
// 	while (i > 0) {
// 		ptr |= i;
// 		ptr <<= 4;
// 		--i;
// 	}
// 	return ptr;
// }


// NOP instruction
#define NOP 0x00000013
/* Now used for dynamic call, never used dynamic lib func!!! */
uint64_t dasics_umaincall_helper(regs_context_t * r_regs)
{
    /* judge t1 to configure where the t1 come from 
     * auipc	t3,0x2
     * ld	t3,-1072(t3) # 2020 <free>
     * jalr	t1,t3
     * nop
     */

    if (_umain_got_table == NULL) goto other_service;

    umain_got_t *entry = _get_trap_area(r_regs->t1);
    // if t3 equal to (uint64_t)dasics_umaincall and 
    // entry not null, it will be a dynamic external
    // function call
    if (entry && r_regs->t3 == (uint64_t)dasics_umaincall && *(uint32_t *)r_regs->t1 == NOP)
    {    
        dasics_dynamic_call(entry, r_regs);
        return 0;
    }
    if (r_regs->ra == (uint64_t)dasics_umaincall)
    {
        dasics_dynamic_return(r_regs);
        return 0;
    }

    if (entry == NULL)
    {
    #ifdef DASICS_DEBUG
        my_printf("[ERROR] DASICS error t1: 0x%lx!\n", r_regs->t1);
    #endif
        // exit(1);
    }

    goto other_service;


other_service:
    // TODO: add other service, such as printf for untrusted area.
    // the other service, maybe we can save a magic number to one
    // register to distinguish other_service, 
    
    r_regs->t1 = r_regs->ra;    
    
    int type = r_regs->a7;
    uint64_t Magic =  r_regs->a6;
    
    if (Magic != MAINCALL_MAGIC) return;

    uint64_t arg0 = r_regs->a0;
    uint64_t arg1 = r_regs->a1;
    uint64_t arg2 = r_regs->a2;
    uint64_t arg3 = r_regs->a3;
    uint64_t arg4 = r_regs->a4;
    uint64_t arg5 = r_regs->a5;




    switch (type)
    {
        // TODO: print supports variable arguments
        case Umaincall_PRINT:
        {
            if (!arg0) break;
            if (arg1) goto print_arg1; 
            printf((char *)arg0);
            break;
        print_arg1:
            if (arg2) goto print_arg2;
            printf((char *)arg0, arg1);
            break;
        print_arg2:
            if (arg3) goto print_arg3;
            printf((char *)arg0, arg1, arg2); 
            break;
        print_arg3:
            printf((char *)arg0, arg1, arg2, arg3);
            break;
        default:
            printf("Warning: Invalid umaincall number %u!\n", type); //could not use // printf in kernel
            break;
        }
        case Umaincall_CALLOC:
        {
            uint64_t size = r_regs->a0 * r_regs->a1;
            r_regs->a0 = calloc(r_regs->a0, r_regs->a1);
            if (r_regs->a0)
            {
                trap_libcfg_alloc(r_regs, \ 
                                 DASICS_LIBCFG_W | DASICS_LIBCFG_R, \
                                 r_regs->a0 + size,
                                 r_regs->a0);
            }
            printf("[DASICS_MAINCALL]: calloc size: %d, resule: 0x%lx\n", size, r_regs->a0);
            break;
        }

        case Umaincall_MALLOC:
        {
            uint64_t size = r_regs->a0;
            r_regs->a0 = malloc(r_regs->a0);

            if (r_regs->a0)
            {
                trap_libcfg_alloc(r_regs, \ 
                                 DASICS_LIBCFG_W | DASICS_LIBCFG_R, \
                                 r_regs->a0 + size,
                                 r_regs->a0);
            }
            printf("[DASICS_MAINCALL]: malloc size %d, resule: 0x%lx\n", size, r_regs->a0);
            printf("[DASICS_MAINCALL]: malloc range 0x%lx ~ 0x%lx\n", r_regs->a0, r_regs->a0 + size);

            break;
        }
    }


}

#pragma GCC push_options
#pragma GCC optimize("O0")

void die_for()
{
    int i = 0x100000;
    while(i-- > 0);
}


#pragma GCC pop_options


void dasics_ufault_handler(regs_context_t * regs)
{
    // Save some registers that should be saved by callees
    int error;
    switch (regs->ucause)
    {
    case DasicsUFetchFault:
        error = handle_DasicsUFetchFault(regs);
        break;
    
    case DasicsULoadFault:
        error = handle_DasicsULoadFault(regs);
        break;

    case DasicsUStoreFault:
        error = handle_DasicsUStoreFault(regs);
        break;
    
    case DasicsEcallFault:
        error = handle_DasicsUEcallFault(regs);
        break;
        
    default:
        my_printf("[ERROR] unhandle ufault: 0x%lx\n", regs->ucause);
        while(1);
        break;
    }
    asm volatile("fence\n");
    if (error == -1)
        exit(1);
}

int32_t dasics_libcfg_alloc(uint64_t cfg, uint64_t lo, uint64_t hi) {
    uint64_t libcfg = csr_read(0x880);  // DasicsLibCfg
    int32_t max_cfgs = DASICS_LIBCFG_WIDTH;
    int32_t step = 4;

    for (int32_t idx = 0; idx < max_cfgs; ++idx) {
        uint64_t curr_cfg = (libcfg >> (idx * step)) & DASICS_LIBCFG_MASK;

        if ((curr_cfg & DASICS_LIBCFG_V) == 0)  // Found available config
        {
            // Write DASICS bounds csr
            switch (idx) {
                case 0:
                    csr_write(0x890, lo);   // DasicsLibBound0Lo
                    csr_write(0x891, hi);   // DasicsLibBound0Hi
                    break;
                case 1:
                    csr_write(0x892, lo);   // DasicsLibBound1Lo
                    csr_write(0x893, hi);   // DasicsLibBound1Hi
                    break;
                case 2:
                    csr_write(0x894, lo);   // DasicsLibBound2Lo
                    csr_write(0x895, hi);   // DasicsLibBound2Hi
                    break;
                case 3:
                    csr_write(0x896, lo);   // DasicsLibBound3Lo
                    csr_write(0x897, hi);   // DasicsLibBound3Hi
                    break;
                case 4:
                    csr_write(0x898, lo);   // DasicsLibBound4Lo
                    csr_write(0x899, hi);   // DasicsLibBound4Hi
                    break;
                case 5:
                    csr_write(0x89a, lo);   // DasicsLibBound5Lo
                    csr_write(0x89b, hi);   // DasicsLibBound5Hi
                    break;
                case 6:
                    csr_write(0x89c, lo);   // DasicsLibBound6Lo
                    csr_write(0x89d, hi);   // DasicsLibBound6Hi
                    break;
                case 7:
                    csr_write(0x89e, lo);   // DasicsLibBound7Lo
                    csr_write(0x89f, hi);   // DasicsLibBound7Hi
                    break;
                case 8:
                    csr_write(0x8a0, lo);   // DasicsLibBound8Lo
                    csr_write(0x8a1, hi);   // DasicsLibBound8Hi
                    break;
                case 9:
                    csr_write(0x8a2, lo);   // DasicsLibBound9Lo
                    csr_write(0x8a3, hi);   // DasicsLibBound9Hi
                    break;
                case 10:
                    csr_write(0x8a4, lo);   // DasicsLibBound10Lo
                    csr_write(0x8a5, hi);   // DasicsLibBound10Hi
                    break;
                case 11:
                    csr_write(0x8a6, lo);   // DasicsLibBound11Lo
                    csr_write(0x8a7, hi);   // DasicsLibBound11Hi
                    break;
                case 12:
                    csr_write(0x8a8, lo);   // DasicsLibBound12Lo
                    csr_write(0x8a9, hi);   // DasicsLibBound12Hi
                    break;
                case 13:
                    csr_write(0x8aa, lo);   // DasicsLibBound13Lo
                    csr_write(0x8ab, hi);   // DasicsLibBound13Hi
                    break;
                case 14:
                    csr_write(0x8ac, lo);   // DasicsLibBound14Lo
                    csr_write(0x8ad, hi);   // DasicsLibBound14Hi
                    break;
                case 15:
                    csr_write(0x8ae, lo);   // DasicsLibBound15Lo
                    csr_write(0x8af, hi);   // DasicsLibBound15Hi
                    break;
                default:
                    break;
            }

            // Write config
            libcfg &= ~(DASICS_LIBCFG_MASK << (idx * step));
            libcfg |= (cfg & DASICS_LIBCFG_MASK) << (idx * step);
            csr_write(0x880, libcfg);   // DasicsLibCfg

            return idx;
        }
    }

    return -1;
}

int32_t dasics_libcfg_free(int32_t idx) {
    if (idx < 0 || idx >= DASICS_LIBCFG_WIDTH) return -1;

    int32_t step = 4;
    uint64_t libcfg = csr_read(0x880);  // DasicsLibCfg
    libcfg &= ~(DASICS_LIBCFG_V << (idx * step));
    csr_write(0x880, libcfg);   // DasicsLibCfg
    return 0;
}

uint32_t dasics_libcfg_get(int32_t idx) {
    if (idx < 0 || idx >= DASICS_LIBCFG_WIDTH) return -1;

    int32_t step = 4;
    uint64_t libcfg = csr_read(0x880);  // DasicsLibCfg
    return (libcfg >> (idx * step)) & DASICS_LIBCFG_MASK;
}

int32_t dasics_jumpcfg_alloc(uint64_t lo, uint64_t hi)
{
    uint64_t jumpcfg = csr_read(0x8c8);    // DasicsJumpCfg
    int32_t max_cfgs = DASICS_JUMPCFG_WIDTH;
    int32_t step = 16;

    for (int32_t idx = 0; idx < max_cfgs; ++idx) {
        uint64_t curr_cfg = (jumpcfg >> (idx * step)) & DASICS_JUMPCFG_MASK;
        if ((curr_cfg & DASICS_JUMPCFG_V) == 0) // found available cfg
        {
            // Write DASICS jump boundary CSRs
            switch (idx) {
                case 0:
                    csr_write(0x8c0, lo);  // DasicsJumpBound0Lo
                    csr_write(0x8c1, hi);  // DasicsJumpBound0Hi
                    break;
                case 1:
                    csr_write(0x8c2, lo);  // DasicsJumpBound1Lo
                    csr_write(0x8c3, hi);  // DasicsJumpBound1Hi
                    break;
                case 2:
                    csr_write(0x8c4, lo);  // DasicsJumpBound2Lo
                    csr_write(0x8c5, hi);  // DasicsJumpBound2Hi
                    break;
                case 3:
                    csr_write(0x8c6, lo);  // DasicsJumpBound3Lo
                    csr_write(0x8c7, hi);  // DasicsJumpBound3Hi
                    break;
                default:
                    break;
            }

            jumpcfg &= ~(DASICS_JUMPCFG_MASK << (idx * step));
            jumpcfg |= DASICS_JUMPCFG_V << (idx * step);
            csr_write(0x8c8, jumpcfg); // DasicsJumpCfg

            return idx;
        }
    }

    return -1;
}

int32_t dasics_jumpcfg_free(int32_t idx) {
    if (idx < 0 || idx >= DASICS_JUMPCFG_WIDTH) {
        return -1;
    }

    int32_t step = 16;
    uint64_t jumpcfg = csr_read(0x8c8);    // DasicsJumpCfg
    jumpcfg &= ~(DASICS_JUMPCFG_V << (idx * step));
    csr_write(0x8c8, jumpcfg); // DasicsJumpCfg
    return 0;
}


void dasics_print_cfg_register(int32_t idx)
{
	printf("DASICS uLib CFG Registers: idx:%x  config: %x \n",idx,dasics_libcfg_get(idx));
}